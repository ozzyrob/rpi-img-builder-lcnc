From cea2eb4763c9ea759decd423dcbabbc0a30b26da Mon Sep 17 00:00:00 2001
From: Patrick Yavitz <pyavitz@gmail.com>
Date: Wed, 6 Nov 2024 14:45:18 -0500
Subject: [PATCH] REVERT: wifi: rtw88: usb: Rework the RX path

https://github.com/lwfinger/rtw88/commit/93896b0a2e5907a7c951eb160ccbc8bae05f851e

Signed-off-by: Patrick Yavitz <pyavitz@gmail.com>
---
 drivers/net/wireless/realtek/rtw88/usb.c | 144 +++++------------------
 drivers/net/wireless/realtek/rtw88/usb.h |   6 -
 2 files changed, 30 insertions(+), 120 deletions(-)

diff --git a/drivers/net/wireless/realtek/rtw88/usb.c b/drivers/net/wireless/realtek/rtw88/usb.c
index 94de772d558f..3a85fad4cbf1 100644
--- a/drivers/net/wireless/realtek/rtw88/usb.c
+++ b/drivers/net/wireless/realtek/rtw88/usb.c
@@ -549,68 +549,53 @@ static void rtw_usb_tx_kick_off(struct rtw_dev *rtwdev)
 	queue_work(rtwusb->txwq, &rtwusb->tx_work);
 }
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 9, 0)
 static void rtw_usb_rx_handler(struct work_struct *work)
 {
 	struct rtw_usb *rtwusb = container_of(work, struct rtw_usb, rx_work);
-#else
-static void rtw_usb_rx_handler(struct rtw_usb *rtwusb)
-{
-#endif
 	struct rtw_dev *rtwdev = rtwusb->rtwdev;
 	const struct rtw_chip_info *chip = rtwdev->chip;
 	u32 pkt_desc_sz = chip->rx_pkt_desc_sz;
 	struct ieee80211_rx_status rx_status;
 	u32 pkt_offset, next_pkt, urb_len;
 	struct rtw_rx_pkt_stat pkt_stat;
-	struct sk_buff *rx_skb;
+	struct sk_buff *next_skb;
 	struct sk_buff *skb;
-	u32 skb_len;
 	u8 *rx_desc;
 	int limit;
 
 	for (limit = 0; limit < 200; limit++) {
-		rx_skb = skb_dequeue(&rtwusb->rx_queue);
-		if (!rx_skb)
+		skb = skb_dequeue(&rtwusb->rx_queue);
+		if (!skb)
 			break;
 
 		if (skb_queue_len(&rtwusb->rx_queue) >= RTW_USB_MAX_RXQ_LEN) {
 			dev_dbg_ratelimited(rtwdev->dev, "failed to get rx_queue, overflow\n");
-			dev_kfree_skb_any(rx_skb);
+			dev_kfree_skb_any(skb);
 			continue;
 		}
 
-		urb_len = rx_skb->len;
-		rx_desc = rx_skb->data;
+		urb_len = skb->len;
 
 		do {
+			rx_desc = skb->data;
 			rtw_rx_query_rx_desc(rtwdev, rx_desc, &pkt_stat,
 					     &rx_status);
 			pkt_offset = pkt_desc_sz + pkt_stat.drv_info_sz +
 				     pkt_stat.shift;
 
-			skb_len = pkt_stat.pkt_len + pkt_offset;
-			if (skb_len > 12000) {
-				rtw_err(rtwdev,
-					"skipping RX URB, packet too big: %u\n",
-					skb_len);
-				break;
-			}
+			next_pkt = round_up(pkt_stat.pkt_len + pkt_offset, 8);
 
-			skb = alloc_skb(skb_len, GFP_ATOMIC);
-			if (!skb) {
-				rtw_err(rtwdev,/// TODO rtw_dbg
-					"failed to allocate RX skb of size %d\n",
-					skb_len);
-				continue; /* try again */
-			}
-
-			skb_put_data(skb, rx_desc, skb_len);
+			if (urb_len >= next_pkt + pkt_desc_sz)
+				next_skb = skb_clone(skb, GFP_KERNEL);
+			else
+				next_skb = NULL;
 
 			if (pkt_stat.is_c2h) {
+				skb_trim(skb, pkt_stat.pkt_len + pkt_offset);
 				rtw_fw_c2h_cmd_rx_irqsafe(rtwdev, pkt_offset, skb);
 			} else {
 				skb_pull(skb, pkt_offset);
+				skb_trim(skb, pkt_stat.pkt_len);
 				rtw_update_rx_freq_for_invalid(rtwdev, skb,
 							       &rx_status,
 							       &pkt_stat);
@@ -619,22 +604,13 @@ static void rtw_usb_rx_handler(struct rtw_usb *rtwusb)
 				ieee80211_rx_irqsafe(rtwdev->hw, skb);
 			}
 
-			next_pkt = round_up(skb_len, 8);
-			rx_desc += next_pkt;
-		} while (rx_skb->data + urb_len > rx_desc + pkt_desc_sz);
+			skb = next_skb;
+			if (skb)
+				skb_pull(skb, next_pkt);
 
-		if (skb_queue_len(&rtwusb->rx_free_queue) >=
-		    RTW_USB_RX_SKB_NUM - RTW_USB_RXCB_NUM) {
-			rtw_err(rtwdev, "freeing excess RX skb\n");
-			dev_kfree_skb_any(rx_skb);
-		} else {
-			skb_queue_tail(&rtwusb->rx_free_queue, rx_skb);
-		}
+			urb_len -= next_pkt;
+		} while (skb);
 	}
-
-	if (limit == 200)
-		rtw_err(rtwdev, "left %u frames in the rx queue for later\n",
-			skb_queue_len(&rtwusb->rx_queue));
 }
 
 static void rtw_usb_read_port_complete(struct urb *urb);
@@ -642,62 +618,25 @@ static void rtw_usb_read_port_complete(struct urb *urb);
 static void rtw_usb_rx_resubmit(struct rtw_usb *rtwusb, struct rx_usb_ctrl_block *rxcb)
 {
 	struct rtw_dev *rtwdev = rtwusb->rtwdev;
-	struct sk_buff *rx_skb;
-	gfp_t priority = in_interrupt() ? GFP_ATOMIC : GFP_KERNEL;
 	int error;
 
-	rx_skb = skb_dequeue(&rtwusb->rx_free_queue);
-	if (!rx_skb) {
-		rtw_err(rtwdev, "allocating new RX skb\n");
-
-		rx_skb = alloc_skb(RTW_USB_MAX_RECVBUF_SZ, priority);
-	}
-
-	if (!rx_skb) {
-		rtw_err(rtwdev, "no free RX skb and alloc_skb failed\n");
-
-		goto try_later;
+	rxcb->rx_skb = alloc_skb(RTW_USB_MAX_RECVBUF_SZ, GFP_ATOMIC);
+	if (!rxcb->rx_skb) {
+		rtw_err(rtwdev, "failed to allocate rx_skb\n");
+		return;
 	}
 
-	rxcb->rx_skb = rx_skb;
-
-	skb_reset_tail_pointer(rxcb->rx_skb);
-	rxcb->rx_skb->len = 0;
-
 	usb_fill_bulk_urb(rxcb->rx_urb, rtwusb->udev,
 			  usb_rcvbulkpipe(rtwusb->udev, rtwusb->pipe_in),
 			  rxcb->rx_skb->data, RTW_USB_MAX_RECVBUF_SZ,
 			  rtw_usb_read_port_complete, rxcb);
 
-	error = usb_submit_urb(rxcb->rx_urb, priority);
+	error = usb_submit_urb(rxcb->rx_urb, GFP_ATOMIC);
 	if (error) {
-		skb_queue_tail(&rtwusb->rx_free_queue, rxcb->rx_skb);
-
+		kfree_skb(rxcb->rx_skb);
 		if (error != -ENODEV)
-			rtw_err(rtwdev, "Err sending rx data urb %d\n", error);
-
-		if (error == -ENOMEM)
-			goto try_later;
-	}
-
-	return;
-
-try_later:
-	rxcb->rx_skb = NULL;
-	queue_work(rtwusb->rxwq, &rtwusb->rx_urb_work);
-}
-
-static void rtw_usb_rx_resubmit_work(struct work_struct *work)
-{
-	struct rtw_usb *rtwusb = container_of(work, struct rtw_usb, rx_urb_work);
-	struct rx_usb_ctrl_block *rxcb;
-	int i;
-
-	for (i = 0; i < RTW_USB_RXCB_NUM; i++) {
-		rxcb = &rtwusb->rx_cb[i];
-
-		if (!rxcb->rx_skb)
-			rtw_usb_rx_resubmit(rtwusb, rxcb);
+			rtw_err(rtwdev, "Err sending rx data urb %d\n",
+				error);
 	}
 }
 
@@ -713,20 +652,15 @@ static void rtw_usb_read_port_complete(struct urb *urb)
 		    urb->actual_length < 24) {
 			rtw_err(rtwdev, "failed to get urb length:%d\n",
 				urb->actual_length);
-			skb_queue_tail(&rtwusb->rx_free_queue, skb);
+			if (skb)
+				dev_kfree_skb_any(skb);
 		} else {
 			skb_put(skb, urb->actual_length);
 			skb_queue_tail(&rtwusb->rx_queue, skb);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 9, 0)
 			queue_work(rtwusb->rxwq, &rtwusb->rx_work);
-#else
-			tasklet_schedule(&rtwusb->rx_tasklet);
-#endif
 		}
 		rtw_usb_rx_resubmit(rtwusb, rxcb);
 	} else {
-		skb_queue_tail(&rtwusb->rx_free_queue, skb);
-
 		switch (urb->status) {
 		case -EINVAL:
 		case -EPIPE:
@@ -744,6 +678,8 @@ static void rtw_usb_read_port_complete(struct urb *urb)
 			rtw_err(rtwdev, "status %d\n", urb->status);
 			break;
 		}
+		if (skb)
+			dev_kfree_skb_any(skb);
 	}
 }
 
@@ -933,34 +869,16 @@ static struct rtw_hci_ops rtw_usb_ops = {
 static int rtw_usb_init_rx(struct rtw_dev *rtwdev)
 {
 	struct rtw_usb *rtwusb = rtw_get_usb_priv(rtwdev);
-	struct sk_buff *rx_skb;
-	int i;
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 9, 0)
-	rtwusb->rxwq = alloc_workqueue("rtw88_usb: rx wq", WQ_BH, 0);
-#else
-	tasklet_init(&rtwusb->rx_tasklet,
-		     (void(*)(unsigned long))rtw_usb_rx_handler,
-		     (unsigned long)rtwusb);
 
 	rtwusb->rxwq = create_singlethread_workqueue("rtw88_usb: rx wq");
-#endif
 	if (!rtwusb->rxwq) {
 		rtw_err(rtwdev, "failed to create RX work queue\n");
 		return -ENOMEM;
 	}
 
 	skb_queue_head_init(&rtwusb->rx_queue);
-	skb_queue_head_init(&rtwusb->rx_free_queue);
 
 	INIT_WORK(&rtwusb->rx_work, rtw_usb_rx_handler);
-	INIT_WORK(&rtwusb->rx_urb_work, rtw_usb_rx_resubmit_work);
-
-	for (i = 0; i < RTW_USB_RX_SKB_NUM; i++) {
-		rx_skb = alloc_skb(RTW_USB_MAX_RECVBUF_SZ, GFP_KERNEL);
-		if (rx_skb)
-			skb_queue_tail(&rtwusb->rx_free_queue, rx_skb);
-	}
 
 	return 0;
 }
@@ -985,8 +903,6 @@ static void rtw_usb_deinit_rx(struct rtw_dev *rtwdev)
 
 	flush_workqueue(rtwusb->rxwq);
 	destroy_workqueue(rtwusb->rxwq);
-
-	skb_queue_purge(&rtwusb->rx_free_queue);
 }
 
 static int rtw_usb_init_tx(struct rtw_dev *rtwdev)
diff --git a/drivers/net/wireless/realtek/rtw88/usb.h b/drivers/net/wireless/realtek/rtw88/usb.h
index ae0af4fdd1c1..86697a5c0103 100644
--- a/drivers/net/wireless/realtek/rtw88/usb.h
+++ b/drivers/net/wireless/realtek/rtw88/usb.h
@@ -38,7 +38,6 @@
 #define RTW_USB_RXAGG_TIMEOUT		10
 
 #define RTW_USB_RXCB_NUM		4
-#define RTW_USB_RX_SKB_NUM		8
 
 #define RTW_USB_EP_MAX			4
 
@@ -76,18 +75,13 @@ struct rtw_usb {
 	int qsel_to_ep[TX_DESC_QSEL_MAX];
 
 	struct workqueue_struct *txwq, *rxwq;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 9, 0)
-	struct tasklet_struct rx_tasklet; // Can't use BH workqueue
-#endif
 
 	struct sk_buff_head tx_queue[RTW_USB_EP_MAX];
 	struct work_struct tx_work;
 
 	struct rx_usb_ctrl_block rx_cb[RTW_USB_RXCB_NUM];
 	struct sk_buff_head rx_queue;
-	struct sk_buff_head rx_free_queue;
 	struct work_struct rx_work;
-	struct work_struct rx_urb_work;
 };
 
 static inline struct rtw_usb_tx_data *rtw_usb_get_tx_data(struct sk_buff *skb)
-- 
2.39.5

